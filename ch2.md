# Types and Functions

## Why Care About Types?

Every expression and function has a type - they share properties with other values with the same type. We can add numbers and concatenate lists. `True` has type Bool, `"foo"` has type String.

Why do things have types? To add abstract interfaces to raw bytes to set them apart as strings, numbers, or airline reservations. They also prevent us from mixing up types so your hotel reservation can't be used as a car rental receipt.

This abstraction lets us ignore implementation details so things work like you assume they will.

Not all type systems are equal, and color the way you use and think about the language. Haskell's type system focuses on abstraction, and lets us write concise, powerful code.

## Haskell's Type System

Haskell types can be *strong*, *static*, and *automatically inferred*. Let's talk more about the strengths/weaknesses of these types and their similarities to other languages.

### Strong Types



### Static Types



### Type Inference



## What to Expect from the Type System

## Some Common Basic Types

## Function Application

## Useful Composite Data Types: Lists and Tuples

## Functions Over Lists and Tuples

### Passing an expression to a Function

## Function Types and Purity

## Haskell Source Files, and Writing Simple Functions

### Just What is a Variable, Anyway?

### Conditional Evaluation

## Understanding Evaluation by Example

### Lazy Evaluation

### A More Involved Example

### Recursion

### Ending the Recursion

### Returning from the Recursion

### What Have We Learned?

## PolyMorphism in Haskell

### Reasoning About Polymorphic Functions

### Further Reading

## The Type of a Function of More Than One Argument

## Why the Fuss Over Purity?

## Conclusion
